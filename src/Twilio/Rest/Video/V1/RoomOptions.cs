/*
 * This code was generated by
 * ___ _ _ _ _ _    _ ____    ____ ____ _    ____ ____ _  _ ____ ____ ____ ___ __   __
 *  |  | | | | |    | |  | __ |  | |__| | __ | __ |___ |\ | |___ |__/ |__|  | |  | |__/
 *  |  |_|_| | |___ | |__|    |__| |  | |    |__] |___ | \| |___ |  \ |  |  | |__| |  \
 *
 * Twilio - Video
 * This is the public Twilio REST API.
 *
 * NOTE: This class is auto generated by OpenAPI Generator.
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */


using System;
using System.Collections.Generic;
using Twilio.Base;
using Twilio.Converters;
using System.Linq;



namespace Twilio.Rest.Video.V1
{

    /// <summary> create </summary>
    public class CreateRoomOptions : IOptions<RoomResource>
    {
        
        ///<summary> Deprecated, now always considered to be true. </summary> 
        public bool? EnableTurn { get; set; }

        
        public RoomResource.RoomTypeEnum Type { get; set; }

        ///<summary> An application-defined string that uniquely identifies the resource. It can be used as a `room_sid` in place of the resource's `sid` in the URL to address the resource, assuming it does not contain any [reserved characters](https://tools.ietf.org/html/rfc3986#section-2.2) that would need to be URL encoded. This value is unique for `in-progress` rooms. SDK clients can use this name to connect to the room. REST API clients can use this name in place of the Room SID to interact with the room as long as the room is `in-progress`. </summary> 
        public string UniqueName { get; set; }

        ///<summary> The URL Twilio should call using the `status_callback_method` to send status information to your application on every room event. See [Status Callbacks](https://www.twilio.com/docs/video/api/status-callbacks) for more info. </summary> 
        public Uri StatusCallback { get; set; }

        ///<summary> The HTTP method Twilio should use to call `status_callback`. Can be `POST` or `GET`. </summary> 
        public Twilio.Http.HttpMethod StatusCallbackMethod { get; set; }

        ///<summary> The maximum number of concurrent Participants allowed in the room. The maximum allowed value is 50. </summary> 
        public int? MaxParticipants { get; set; }

        ///<summary> Whether to start recording when Participants connect. </summary> 
        public bool? RecordParticipantsOnConnect { get; set; }

        ///<summary> An array of the video codecs that are supported when publishing a track in the room.  Can be: `VP8` and `H264`. </summary> 
        public List<RoomResource.VideoCodecEnum> VideoCodecs { get; set; }

        ///<summary> The region for the Room's media server.  Can be one of the [available Media Regions](https://www.twilio.com/docs/video/ip-addresses#group-rooms-media-servers). </summary> 
        public string MediaRegion { get; set; }

        ///<summary> A collection of Recording Rules that describe how to include or exclude matching tracks for recording </summary> 
        public object RecordingRules { get; set; }

        ///<summary> When set to true, indicates that the participants in the room will only publish audio. No video tracks will be allowed. </summary> 
        public bool? AudioOnly { get; set; }

        ///<summary> The maximum number of seconds a Participant can be connected to the room. The maximum possible value is 86400 seconds (24 hours). The default is 14400 seconds (4 hours). </summary> 
        public int? MaxParticipantDuration { get; set; }

        ///<summary> Configures how long (in minutes) a room will remain active after last participant leaves. Valid values range from 1 to 60 minutes (no fractions). </summary> 
        public int? EmptyRoomTimeout { get; set; }

        ///<summary> Configures how long (in minutes) a room will remain active if no one joins. Valid values range from 1 to 60 minutes (no fractions). </summary> 
        public int? UnusedRoomTimeout { get; set; }

        ///<summary> When set to true, indicated that this is the large room. </summary> 
        public bool? LargeRoom { get; set; }



        
        /// <summary> Generate the necessary parameters </summary>
        public List<KeyValuePair<string, string>> GetParams()
        {
            var p = new List<KeyValuePair<string, string>>();

            if (EnableTurn != null)
            {
                p.Add(new KeyValuePair<string, string>("EnableTurn", EnableTurn.Value.ToString().ToLower()));
            }
            if (Type != null)
            {
                p.Add(new KeyValuePair<string, string>("Type", Type.ToString()));
            }
            if (UniqueName != null)
            {
                p.Add(new KeyValuePair<string, string>("UniqueName", UniqueName));
            }
            if (StatusCallback != null)
            {
                p.Add(new KeyValuePair<string, string>("StatusCallback", Serializers.Url(StatusCallback)));
            }
            if (StatusCallbackMethod != null)
            {
                p.Add(new KeyValuePair<string, string>("StatusCallbackMethod", StatusCallbackMethod.ToString()));
            }
            if (MaxParticipants != null)
            {
                p.Add(new KeyValuePair<string, string>("MaxParticipants", MaxParticipants.ToString()));
            }
            if (RecordParticipantsOnConnect != null)
            {
                p.Add(new KeyValuePair<string, string>("RecordParticipantsOnConnect", RecordParticipantsOnConnect.Value.ToString().ToLower()));
            }
            if (VideoCodecs != null)
            {
                p.AddRange(VideoCodecs.Select(VideoCodecs => new KeyValuePair<string, string>("VideoCodecs", VideoCodecs.ToString())));
            }
            if (MediaRegion != null)
            {
                p.Add(new KeyValuePair<string, string>("MediaRegion", MediaRegion));
            }
            if (RecordingRules != null)
            {
                p.Add(new KeyValuePair<string, string>("RecordingRules", Serializers.JsonObject(RecordingRules)));
            }
            if (AudioOnly != null)
            {
                p.Add(new KeyValuePair<string, string>("AudioOnly", AudioOnly.Value.ToString().ToLower()));
            }
            if (MaxParticipantDuration != null)
            {
                p.Add(new KeyValuePair<string, string>("MaxParticipantDuration", MaxParticipantDuration.ToString()));
            }
            if (EmptyRoomTimeout != null)
            {
                p.Add(new KeyValuePair<string, string>("EmptyRoomTimeout", EmptyRoomTimeout.ToString()));
            }
            if (UnusedRoomTimeout != null)
            {
                p.Add(new KeyValuePair<string, string>("UnusedRoomTimeout", UnusedRoomTimeout.ToString()));
            }
            if (LargeRoom != null)
            {
                p.Add(new KeyValuePair<string, string>("LargeRoom", LargeRoom.Value.ToString().ToLower()));
            }
            return p;
        }

        

    }
    /// <summary> fetch </summary>
    public class FetchRoomOptions : IOptions<RoomResource>
    {
    
        ///<summary> The SID of the Room resource to fetch. </summary> 
        public string PathSid { get; }



        /// <summary> Construct a new FetchRoomOptions </summary>
        /// <param name="pathSid"> The SID of the Room resource to fetch. </param>
        public FetchRoomOptions(string pathSid)
        {
            PathSid = pathSid;
        }

        
        /// <summary> Generate the necessary parameters </summary>
        public List<KeyValuePair<string, string>> GetParams()
        {
            var p = new List<KeyValuePair<string, string>>();

            return p;
        }

    

    }


    /// <summary> read </summary>
    public class ReadRoomOptions : ReadOptions<RoomResource>
    {
    
        ///<summary> Read only the rooms with this status. Can be: `in-progress` (default) or `completed` </summary> 
        public RoomResource.RoomStatusEnum Status { get; set; }

        ///<summary> Read only rooms with the this `unique_name`. </summary> 
        public string UniqueName { get; set; }

        ///<summary> Read only rooms that started on or after this date, given as `YYYY-MM-DD`. </summary> 
        public DateTime? DateCreatedAfter { get; set; }

        ///<summary> Read only rooms that started before this date, given as `YYYY-MM-DD`. </summary> 
        public DateTime? DateCreatedBefore { get; set; }




        
        /// <summary> Generate the necessary parameters </summary>
        public List<KeyValuePair<string, string>> GetParams()
        {
            var p = new List<KeyValuePair<string, string>>();

            if (Status != null)
            {
                p.Add(new KeyValuePair<string, string>("Status", Status.ToString()));
            }
            if (UniqueName != null)
            {
                p.Add(new KeyValuePair<string, string>("UniqueName", UniqueName));
            }
            if (DateCreatedAfter != null)
            {
                p.Add(new KeyValuePair<string, string>("DateCreatedAfter", Serializers.DateTimeIso8601(DateCreatedAfter)));
            }
            if (DateCreatedBefore != null)
            {
                p.Add(new KeyValuePair<string, string>("DateCreatedBefore", Serializers.DateTimeIso8601(DateCreatedBefore)));
            }
            if (PageSize != null)
            {
                p.Add(new KeyValuePair<string, string>("PageSize", PageSize.ToString()));
            }
            return p;
        }

    

    }

    /// <summary> update </summary>
    public class UpdateRoomOptions : IOptions<RoomResource>
    {
    
        ///<summary> The SID of the Room resource to update. </summary> 
        public string PathSid { get; }

        
        public RoomResource.RoomStatusEnum Status { get; }



        /// <summary> Construct a new UpdateRoomOptions </summary>
        /// <param name="pathSid"> The SID of the Room resource to update. </param>
        /// <param name="status">  </param>
        public UpdateRoomOptions(string pathSid, RoomResource.RoomStatusEnum status)
        {
            PathSid = pathSid;
            Status = status;
        }

        
        /// <summary> Generate the necessary parameters </summary>
        public List<KeyValuePair<string, string>> GetParams()
        {
            var p = new List<KeyValuePair<string, string>>();

            if (Status != null)
            {
                p.Add(new KeyValuePair<string, string>("Status", Status.ToString()));
            }
            return p;
        }

        

    }


}

